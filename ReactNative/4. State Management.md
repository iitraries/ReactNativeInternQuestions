**Category purpose:** Scaling .
## A. Local State vs Global State (Core Judgment)

1. What criteria would you use to decide whether a piece of state should be **local to a component** or **shared globally**?
2. Why does moving state “just in case” to a global store often make an app **harder to reason about**?
3. What kinds of bugs appear when state that is **conceptually local** is made global?
4. Can something be **global in visibility** but still **local in ownership**? Explain with an example.
5. Why is UI state (like modals, loaders, selected tabs) usually a poor fit for global stores?

---

## B. Context API — Strengths & Breaking Points

6. What problem does the **Context API** solve that props alone cannot?
7. Why does Context scale poorly when it is used as a **general state container**?
8. What actually causes **all consumers of a context to re-render**, even if they don’t use the changed value?
9. Why does splitting one large context into multiple smaller contexts sometimes improve performance?
10. In what situations does Context introduce **hidden coupling** between unrelated parts of the app?

---

## C. Redux / Zustand / Recoil — High-Level Tradeoffs

11. What category of problems is Redux designed to solve, conceptually?
12. Why is Redux often considered **overkill** for small or medium React Native apps?
13. What does a centralized store **give you**, and what does it **take away**?
14. How do lighter state libraries (like Zustand or Recoil) differ **philosophically**, not syntactically, from Redux?
15. Why can having “one source of truth” become a liability instead of a benefit?

---

## D. Async State & Side Effects
16. Why is async state fundamentally harder to manage than synchronous state?
17. What problems arise when **loading, success, and error** are not modeled explicitly in state?
18. Why can race conditions occur when multiple async requests update the same state?
19. How can async logic accidentally overwrite **newer data with older responses**?
20. Why does colocating async logic with UI components often lead to fragile code?

---

## E. State Ownership & Data Flow
21. What does it mean for a piece of state to have a **single clear owner**, and why is that important?
22. Why do apps become difficult to debug when **multiple systems can mutate the same state**?
23. How does unidirectional data flow simplify reasoning about state changes?
24. What happens when state updates are triggered implicitly rather than explicitly?

---

## F. Performance & Re-render Implications
25. How does global state increase the **blast radius** of a single state change?
26. Why does subscribing many components to global state often cause unnecessary re-renders?
27. How does selector design affect performance in state-management solutions?
28. Why is state normalization sometimes required at scale?

---

## G. Selection-Booster Conceptual Questions
29. In what exact scenarios is Redux the **right tool**, despite its complexity?
30. At what scale or complexity does Context **stop being sufficient**, and why?
31. Why is choosing _where_ state lives often more important than _which library_ you use?
32. How would you redesign state management if performance suddenly became a critical constraint?
33. What warning signs indicate that state management has become the **main source of bugs** in an app?
34. If you were starting a new RN app today, how would you **delay committing** to a global state solution without blocking future scale?