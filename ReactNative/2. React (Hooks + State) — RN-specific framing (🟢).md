**Category purpose:** Detects real React competence.
## A. State & Re-Render Mechanics (RN Context)
1. What **exactly causes a component to re-render** in React Native? List all valid triggers.
2. Why does calling `setState` with the **same value** sometimes still cause a re-render?
3. How does React decide **which components re-render** after a state update?
4. What is the difference between **state updates being batched vs not batched**, and why does this matter on mobile?
5. Why is frequent re-rendering more dangerous in React Native than on the web?
---

## B. `useState` — Beyond Basics
6. Why is updating state based on **previous state** sometimes buggy if written incorrectly?
7. What happens if you update state **inside a render path** (directly or indirectly)?
8. Why should large objects or arrays in state be treated carefully in React Native?

---

## C. `useEffect` — Lifecycle & Traps
9. When does `useEffect` **run for the first time**, and when does it **not run at all**?
10. What exactly does the **dependency array** control, and how does React compare dependencies?
11. Why does leaving the dependency array empty sometimes introduce **hard-to-detect bugs**?
12. What happens if a value used inside `useEffect` is **not listed** in the dependency array?
13. How does cleanup in `useEffect` work, and **when is it executed**?
14. Why is `useEffect` misuse a common cause of **memory leaks** in React Native apps?

---

## D. `useRef` — Identity vs Rendering
15. What is `useRef` actually storing, and **where does it live** across renders?
16. Why does mutating `useRef.current` **not trigger a re-render**?
17. When would `useRef` be preferred over `useState` in React Native?
18. How is `useRef` commonly used to interact with **native components**?

---

## E. Memoization Hooks (`useMemo`, `useCallback`)
19. What problem do `useMemo` and `useCallback` solve in React Native specifically?
20. Why can **overusing memoization** actually hurt performance?
21. What happens internally if the dependency array of `useCallback` is wrong?
22. Why does passing inline functions to child components often cause **unnecessary re-renders**?
23. In what situations does memoization **not help at all**?

---

## F. Controlled vs Uncontrolled Components
24. What is the difference between **controlled and uncontrolled components** in React Native?
25. Why are controlled inputs more common in React Native than uncontrolled ones?
26. What performance tradeoffs exist when using controlled inputs on mobile?

---

## G. State Placement & Data Flow
27. When should state be kept **local**, and when should it be **lifted up**?
28. What problems arise when state is lifted **too high** in the component tree?
29. What is **props drilling**, and why does it scale poorly?
30. Why does Context solve some problems but introduce **new performance concerns**?

---

## H. Selection-Booster Conceptual Questions
31. Why do stale closure bugs happen even though JavaScript is single-threaded?
32. How can hooks lead to **logic bugs that don’t throw errors**, only wrong behavior?
33. If a component re-renders unexpectedly, how would you **systematically debug why**?
34. Why is understanding render behavior more important than memorizing hook APIs?
