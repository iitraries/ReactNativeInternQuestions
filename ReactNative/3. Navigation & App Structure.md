**Category purpose:** Can you build a real app?

## A. Navigation Mental Model (React Navigation)
1. What is **navigation state**, and what information does it represent internally?
2. How does **React Navigation** keep track of the current screen without relying on URLs like the web?
3. Why is navigation considered **application state**, but not **business state**?
4. What happens internally when a screen is pushed onto a stack navigator?
5. Why does React Navigation require components to be wrapped in a **NavigationContainer**?

---

## B. Stack / Tab / Drawer Navigators

6. In what scenarios is a **stack navigator** the correct choice?
7. When does a **tab navigator** become problematic from a UX or state perspective?
8. What are the tradeoffs of using a **drawer navigator** on mobile?
9. How do nested navigators work (e.g., stack inside tabs), and why are they common in real apps?
10. What kinds of bugs appear when navigators are **incorrectly nested**?

---

## C. Screen Lifecycle & Rendering

11. When you navigate away from a screen, is it **destroyed or kept in memory**?  
    What determines this behavior?
12. What lifecycle-like events exist for screens, and **why are they needed**?
13. Why does relying only on `useEffect` for screen focus logic often fail?
14. What problems arise if API calls are triggered **every time a screen gains focus**?
15. How do you prevent stale data when navigating back to a previously visited screen?

---

## D. Passing Data Between Screens

16. What are the valid ways to **pass data between screens** in React Navigation?
17. Why is passing **large objects** through navigation params discouraged?
18. What happens if params change but the screen **does not re-mount**?
19. How would you pass data **back to a previous screen** without global state?
20. Why is navigation param misuse a common source of **tight coupling**?

---

## E. `navigate` vs `push` (Selection Booster)

21. What is the **exact difference** between `navigate` and `push`?
22. Why can `navigate` sometimes appear to “do nothing”?
23. In what situation would using `push` cause **unexpected memory growth**?
24. How does screen identity affect whether `navigate` reuses or creates a screen?

---

## F. Navigation State vs Global State (Selection Booster)

25. Why should **navigation state not be stored in Redux or other global stores**?
26. What kinds of bugs occur when navigation is driven by external state changes?
27. Why does React Navigation intentionally **own its own state**?

---

## G. Deep Linking (Awareness-Level)

28. What is deep linking in a mobile app, conceptually?
29. How does a deep link map to a specific screen and params?
30. What problems arise if deep linking is added **late** in a project?
31. Why is deep linking harder on mobile than routing on the web?

---

## H. Real-World Pitfalls & Debugging

32. Why do navigation bugs often **look like state bugs**?
33. What causes screens to re-render even when navigation doesn’t change?
34. How would you debug an issue where navigation works on Android but fails on iOS?
35. What are common beginner mistakes in structuring navigation for scalable apps?
